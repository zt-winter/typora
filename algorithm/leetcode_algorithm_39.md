# leetcode算法39

给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。

candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 

对于给定的输入，保证和为 target 的唯一组合数少于 150 个。

```
输入: candidates = [2,3,6,7], target = 7
输出: [[7],[2,2,3]]
```

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

解题思路：

​	我自己考虑的是使用动态规划的方法，从最后一个数组元素开始，将它存在0个到存在N个的解列出，这样就可以将问题化归为数组candidates[0:n-2]，target=target-N*lastone的问题，相当于每一步都对数组进行了简化。一直化归到数组为0或者为1。

​	问题是： vector\<vector>递归返回后的值还需要每个都加上lastone的个数，数组长度为0或者为1的时候的处理都变得非常麻烦。因为涉及到vector\<vector\<int>>的反复处理，代码变得非常难写。



​	答案的思路是不对candidate数组进行简化，而是对target进行简化，将0和数组中各种值去减target，通过缩小target，来实现递归。

​	还有编程技巧上的一点，答案在实现时是通过重新构造递归函数，然后在参数中填入每一个种可能的解法，这样当target为0时就可以输出判断。
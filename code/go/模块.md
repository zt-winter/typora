# 模块 module

一个基本模块的创建

```go
# cd ~/code/go
# mkdir greetings && cd greetings
# go mod init test.com/greetings
go: creating new go.mod: module test.com/greetings
# vim greetings.go
//函数首字母大写，表示该函数可以被其他包调用
package greetings

import "fmt"

func Hello(name string) string {
        message := fmt.Sprintf("Hi, %v. welcome!", name)
        return message
}
```

一个模块调用另一个模块

```go
# cd ~/code/go
# mkdir hello && cd hello
# go mod init test.com/hello
go: creating new go.mod: module test.com/hello
# vim hello.go
package main

import(
        "fmt"
        "test.com/greetings"
)

func main() {
        message := greetings.Hello("Gladys")
        fmt.Println(message)
}
```

​		上面这种包引用情况是，你将greetings里所有函数打包，然后形成greetings包上传到test.com中，然后在写hello时要调用greetings中的函数，就直接从网上下载，然后使用。但很多时候，一个大项目中许多小项目要互相引用，但有要引用的项目还没有上线，或者两个项目都在一个主机上，那么该如何引用其中的函数呢？这里提供方法，就是相对于本项目，指出要引用的包的路径。

​		这里我们要引用greetings中函数

```go
# tree
.
├── greetings
│   ├── go.mod
│   └── greetings.go
├── hello
│   ├── go.mod
│   └── hello.go
└── pkg
    └── mod
        └── cache
            └── lock
/* 	在hello目录的命令提示符下执行下列命令
	将go.mod文件中test.com/greetings替换为../greetings
	当前目录~/code/go/hello，那么../greetings就是
	~/code/go/greetings目录
*/
# go mod edit -replace test.com/greetings=../greetings

/*	在hello目录的命令提示符下执行下列命令
	该命令会在刷新同步test.com/hello模块的依赖，
	自动添加不全所需要的代码
*/
# go mod tidy
go: found test.com/greetings in test.com/greetings v0.0.0-00010101000000-000000000000

//	这之后go.mod文件的内容
module test.com/hello

go 1.17

replace test.com/greetings => ../greetings

require test.com/greetings v0.0.0-00010101000000-000000000000
# go run .
Hi, Gladys. welcome!
```

这里我们继续添加一个模块，模块位于hello模块中。目录结构如下

```
# mkdir ./hello/submodule
# tree
├── greetings
│   ├── go.mod
│   └── greetings.go
├── hello
│   ├── go.mod
│   ├── hello
│   ├── hello.go
│   └── submodule
└── pkg
    └── mod
        └── cache
            └── lock
```

```go
//	我们在submodule文件夹下开始新的模块的建立
# go mod init test.com/submodule
# vim submodule.go
package submodule

import "fmt"

func Test() int {
        fmt.Println("This is a test module")
        return 1
}
//	然后我们回到hello目录下
# vim hello.go
package main

import(
        "fmt"
        "test.com/greetings"
        "test.com/submodule"
)

func main() {
        message := greetings.Hello("Gladys")
        fmt.Println(message)
        submodule.Test()
}
# go mod edit -replace test.com/submodule=./submodule
# go mod tidy
go: found test.com/submodule in test.com/submodule v0.0.0-00010101000000-000000000000
# go run .
Hi, Gladys. welcome!
This is a test module
```

